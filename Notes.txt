Outline

* This is a discussion about types as they're used in day-to-day development - there will be code, and it'll
only take about 20 minutes to go through the content, so feel free to interrupt and ask questions as I go along.
* I'll do my best to define terms as I go, but if I miss something or if I've explained it badly feel free
to interrupt.
* Most of the examples will be in Java, once again, please ask if the syntax doesn't make sense
* I hope I'll prompt developers in any language to think about whether they could use types more effectively.
* One last thing; although I prefer static typing, this isn't about bashing dynamically-typed languages,
but it may give some insight into why some people are more than happy to spend time making the compiler happy.


What

* First, a definition
* Types represent a way to hold some state in our programs
* To be useful we'll write code that uses instances of these types, or maybe returns them
* In the OO paradigm that's usually methods and state in a class
* Procedural and functional styles might include functions and the types they work with in a common module


Types

* Most languages have a core set of types to work with
* There will be one or more numeric types - perhaps different types for integers or floating-point numbers, and
sometimes many refinements on these basic values.
* Character types, such as strings are a basic commodity
* Almost all languages have the concept of a boolean value; something which is either true or false
* Then there are collection types; lists, sets, arrays, dictionaries, tuples and more


Constraints

* By choosing a type to represent a concept we constrain it in some way.
* Choosing integer over float excludes an infinity of possible values
* although we'd certainly want a counter to represent whole numbers, we probably don't want to allow
negative values - that's an extra bit of knowledge specific to how it's being used that.
* Picking a set, or a list, or an array, expresses and limits choices about the values that will
be stored and how we plan to retrieve them.
* Sets don't allow duplicates, lists aren't good for random access
* SQL defines a choice of character types, and allows limits to be set on the size
* Some environments allow a choice of un-modifiable, or immutable, collections; an important safety feature
when shared with concurrent threads.
* So, an important part of the process of low level design for an application is the choice of constraints.


Typing

* We tend to talk about types in a pretty loose way; languages may be described as having weak or
strong type systems but I couldn't find good definitions for what those terms really mean.
* A clearer distinction is between static type-checking (at compile time) and dynamic type-checking at run time
* There are trade-offs to be made by language designers
** Type checks need extra work at compile time, it takes longer between making a change and being able to run it
** but errors like typo's won't show up until runtime if the checks don't happen during compilation
** Types in code, whether compiled or not, help to explain the logic to another programmer
** but some strongly typed languages clutter source code with duplicated detail; Java is prone to this
