Outline

* This is a discussion about types as they're used in day-to-day development - there will be code, and it'll
only take about 20 minutes to go through the content, so feel free to interrupt and ask questions as I go along.
* I'll do my best to define terms as I go, but if I miss something or if I've explained it badly feel free
to interrupt.
* Most of the examples will be in Java, once again, please ask if the syntax doesn't make sense
* I hope I'll prompt developers in any language to think about whether they could use types more effectively.
* One last thing; although I prefer static typing, this isn't about bashing dynamically-typed languages,
but it may give some insight into why some people are more than happy to spend time making the compiler happy.


What

* First, a definition
* Types represent a way to hold some state in our programs
* To be useful we'll write code that uses instances of these types, or maybe returns them
* In the OO paradigm that's usually methods and state in a class
* Procedural and functional styles might include functions and the types they work with in a common module


Types

* Most languages have a core set of types to work with
* There will be one or more numeric types - perhaps different types for integers or floating-point numbers, and
sometimes many refinements on these basic values.
* Character types, such as strings are a basic commodity
* Almost all languages have the concept of a boolean value; something which is either true or false
* Then there are collection types; lists, sets, arrays, dictionaries, tuples and more


Constraints

* By choosing a type to represent a concept we constrain it in some way.
* Choosing integer over float excludes an infinity of possible values
* although we'd certainly want a counter to represent whole numbers, we probably don't want to allow
negative values - that's an extra bit of knowledge specific to how it's being used that.
* Picking a set, or a list, or an array, expresses and limits choices about the values that will
be stored and how we plan to retrieve them.
* Sets don't allow duplicates, lists aren't good for random access
* SQL defines a choice of character types, and allows limits to be set on the size
* Some environments allow a choice of un-modifiable, or immutable, collections; an important safety feature
when shared with concurrent threads.
* So, an important part of the process of low level design for an application is the choice of constraints.


Typing

* We tend to talk about types in a pretty loose way; languages may be described as having weak or
strong type systems but I couldn't find good definitions for what those terms really mean.
* A clearer distinction is between static type-checking (at compile time) and dynamic type-checking at run time
* There are trade-offs to be made by language designers
** Type checks need extra work at compile time, it takes longer between making a change and being able to run it
** but errors like typo's won't show up until runtime if the checks don't happen during compilation
** Types in code, whether compiled or not, help to explain the logic to another programmer
** but some strongly typed languages clutter source code with duplicated detail; Java is prone to this


Dynamic

* This is an example in Ruby, a language with runtime type-checking
* The `greet` function uses the `+` *method* on the "Hello " string, which
expects another string on the right-hand side.
* Nowhere does the code explicitly state what type `name` has, or what type is returned
* We can call `greet` and pass any object we want, but unless it is a string we'll get
an error when we run it
** `(no implicit conversion of Integer into String)`
* When writing production software some extra test effort is needed to make sure everything
lines up
** It's not unusual for Ruby projects to require 100% coverage of all code with automated tests


Static

* Here's the equivalent Java code, notice that both the `name` parameter and the return value have an explicit type
* It's impossible to build code where `greet` is called with anything *except* a `String`
* So that's it; Java is type-safe, it's impossible to get a runtime error for an invalid type.


Object


* Java has the special `Object` class that every class inherits from
* As it happens, the code above both compiles *and* runs successfully because in Java the '+' the right hand side
has `toString()` called on it - changing the type to `String`
