= How strong are your types?
2019-07-31
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: src]
:source-highlighter: highlightjs
:icons: font
:revealjs_theme: sky
:revealjs_slideNumber: h.v


== Outline
* An overview of typing
* The type that wasn't there
* Making types work harder

[.notes]
--
* Types and how they're used
* Getting more value
* Not bashing dynamic typing
* Feel free to interrupt

+60
--

== What is a 'Type'
* State / Information
* Will have operations associated with it
** Part of the type - Objects and methods
** Functions which take or return the type

[.notes]
--
* Definition: "model a concept in our programs"
* Information / state
* Associated operations - methods / functions
* Instances passed around

+30
--

== Types of Types
* Numeric types
* Character types
* Booleans
* Collection types

[.notes]
--
* Core types
* Part of the language or standard library
* Integers, floating-point
* Strings
* True / False
* Lists, Sets, Arrays, Dictionaries, Tuples

+30
--

== Types as Constraints

[source,kotlin]
----
Integer counter      = 100;
Float   interestRate = 0.12f;
Set     attendees;
List    snmpTraps;

VARCHAR2(20)
----

[.notes]
--
* Choice of type for concept constrains
* Height - units, precision int/float?
* Counter - int, but what about -ve
* List vs Array - random access / iteration / insertion
* Attendees for meeting - Set (duplicates)
* SNMP traps received - List (order + duplicates)
* Choice of type = choice of concept
* Important low-level design

+60
--

== Types of Typing
* Checked/Unchecked/Weak/Strong
* Static/Dynamic
* Trade-offs
** Compilation cost
** Feedback time for mistakes
** Clarity/Verbosity

[.notes]
--
* Weak vs Strong - no good definition
* Static vs dynamic
* Compile vs runtime
* Compilation takes time - increases feedback cycle
* Finds some bugs early - faster feedback
* Types help explain code - improve comprehension
* Syntax can clutter - harder to read

+60
--

=== Dynamic
[source,ruby]
----
def greet(name)
  return "Hello " + name
end

greet("Tony") # Hello Tony
greet(3)      # TypeError (runtime)
----
* Ruby determines the type of a reference at runtime
** The 'shape' of the object is _assumed_
* Test coverage is important to check assumptions

[.notes]
--
* '+' method called on "Hello "
* No explicit 'String' mentioned
* Can pass *anything* to greet()
* Evaluated at runtime
* Error if wrong 'shape'
* Use tests to check assumptions

+60
--

=== Static
[source,java]
----
String greet(String name) {
    return "Hello " + name;
}

greet("Tony");

greet(3); // Compilation fails
----
* Java *must* know the type of a reference at compile time
** The 'shape' of the object is _known_
* No type errors at run time?

[.notes]
--
* '+' is an operator (not a method)
* Explicit type of parameter & return
* Wrong type *impossible*
* Means no runtime type-errors?

+30
--

=== Well ...



=== `Object`

[source,java]
----
String greet(Object name) {
    return "Hello " + name;
}

greet("Tony");

greet(3);           // Hello 3
greet(new Timer()); // Hello java.util.Timer@604ed9f0
----

* Successful, but not checked until runtime

[.notes]
--
* Almost same - Object parameter
* Works by coincidence
* May give rubbish result - toString()

+45
--

=== What about ...?

[source,java]
----
String greet(Object name, Object repeat) {
    return "Hello ".repeat((int)repeat) + name;
}

greet("Tony", 3);
greet(3, "Tony"); // runtime exception
----
* Compiles
* Runtime exception
* But who'd do that?

[.notes]
--
* More extreme example
* New greet()
* Say greeting n-times
* Exception this time
* 'repeat' -cast-> int
* Dynamic typing possible in Java
* Also reflection & instanceof
* Contrived example

+45
--

=== The Type that wasn't there

[source,java]
----
String greetMany(Map<String, Integer> peopleToGreet) {
    var greetings = new StringBuilder();
    peopleToGreet.forEach( (name, repeat) -> {
        greetings.append("Hello ".repeat(repeat) + name);
    });
    return greetings.toString();
}

Map people = Map.of(
    "Tony", 3,
    3,      "Tony"
);

greetMany(people); // runtime exception
----
* Compiles
* Runtime exception
* But who'd do that?

[.notes]
--
* Extended again
* greet many people
* peopleToGreet Map with generics
* iterate + build
* var inference, Map initialisation
* Runtime failure
* 'Raw' collections => history
* Well defined contract, realistic mistake

+80
--

=== Stringly-typed code

[source,java]
----
String greet(String name, String place) {
    return "Hello " + name + " from " + place;
}

greet("Alice", "London"); // Hello Alice from London
greet("Leeds", "Bob");    // Hello Leeds from Bob

----
* Runtime confusion

[.notes]
--
* Included types not always enough
* Obvious intent - wrong outcome
* More parameters common
* Passed around & re-ordered
* More subtle bugs
* Compiler can't check the contract

+45
--

== Micro Types

=== Is this better?
[source,java]
----
String greet(Name person, City city) {
    return "Hello " + person.givenName + " from " + city;
}

Name theresa = new Name("May", "Theresa");
City london = City.of("London");

greet(theresa, london);
greet(london, theresa); // compile fails

----

[.notes]
--
* Same method
* Stronger contract
* Compile fails if wrong way around

+30
--

=== Why 'micro' types
[source,java]
----
class Name {
    final String familyName, givenName;

    Name(String familyName, String givenName) {
        this.familyName = familyName;
        this.givenName = givenName;
    }
}
----

[.notes]
--
* New types can be tiny
* Immutable wrapper
* Expresses concept
* One place to change

+30
--

=== We can go further
[source,java]
----
// A parent class to hold common behaviour
abstract class Type<T> {
    final T value;
    protected Type(final T value) { this.value = value; }
    @Override String toString() { return value.toString(); }
}

// Define some subclasses
class GivenName extends Type<String> {
    GivenName(String value) { super(value); }
}

class Height extends Type<Integer> {
    Height(Integer value) { super(value); }
}

// Use them
var tony = new GivenName("Tony");
var tonyHeight = new Height(180);

displayHeight(tony, tonyHeight);

----

[.notes]
--
* Easy reusable code
* EXPLAIN

+30
--

=== Literate API
[source,java]
----
class GivenName extends Type<String> {
    // ...
    static GivenName of(String name) {
        return new GivenName(name);
    }
}

class Height extends Type<Integer> {
    // ...
    static Height cm(int value) {...}
    static Height imperial(int feet, int inches) {...}
    static Height meters(float value) {...}
}

var tony = GivenName.of("Tony");
var tonyHeight = Height.cm(180);
var gregHeight = Height.imperial(6, 1);
----

[.notes]
--
* EXPLAIN
* Factory methods can make easier to read
* Further express concepts - different units of height
--


=== Why they're useful
[source,java]
----
LatLon position = london.location();

Person buildPerson(GivenName givenName, FamilyName familyName) {...}
Person buildPerson(Name name) {...}
Person buildPerson(Name name, Age age, Height height) {...}

//Person buildPerson(Name name, Integer age/height???) {...}
Person buildPerson(Name name, Age age) {...}
Person buildPerson(Name name, Height height) {...}
----
* Good OO
* Refactoring
* Overloaded methods
* Compile-time safety
* IDE auto-completion

[.notes]
--
* Good OO style - state + methods
* Once place to change
* Overloading - EXPLAIN Age/Height
* Auto-complete
* Compile time contract

+60
--

== Enumerations
[source,java]
----
enum RAG {Red, Amber, Green}

switch (rag) {
    case Red: System.out.println("ERROR"); break;
    case Amber: System.out.println("WARNING"); break;
}
----
* A fixed set of options
* Can also implement an `interface`

[.notes]
--
* Excellent for fixed set values
* EXPLAIN
* Language support
* Static analysis spots incomplete
* Can add behaviour - state machine

+30
--

== Nullable?
* A `String` which can hold a null reference
* A `String` which can only have a value
** Are they the same type?

[source,java]
----
// Kotlin
val nullable: String? = null   // OK
val notNullable: String = null // compilation error
----

[.notes]
--
* Tony Hoare - "million dollar mistake"
* Kotlin makes distinction


+45
--

== Types-in-a-box
* These types express uncertainty
* Can defer resolving the uncertainty
* Something like schr√∂dinger's cat

[.notes]
--
* There are another category of types that are becoming more common as functional-style
programming gains popularity
* These types can be seen as expressing uncertainty about a value; it may be present or not, it might be
one thing or another, or an error may have been thrown while processing.
* The key thing is that this uncertainty is captured in the type system - a program that receives such a type
*must* resolve the uncertainty in order to continue.

+30
--

=== Optional
* A result that may not be there

[source,java]
----
Optional<TimeSlot> nextFreeMeetingSlot(Criteria criteria) {...}

Meeting meeting = nextFreeMeetingSlot(criteria)
                    .orElse(TimeSlot.EMPTY);
----

[.notes]
--
* The `nextFreeSlot` method returns an `Optional` type which wraps a result, in this case there
may or may not be a free time slot that meets the criteria.
* An alternative way to handle this might be to return `null`, but unless the programmer calling
`nextFreeSlot` is familiar with the implementation this is a `NullPointerException` waiting to happen.
* Or the `nextFreeSlot` might throw an exception itself, but handling exceptions breaks up the program
flow and makes code harder to understand
* With `Optional` a developer is forced to make a choice about how to handle the happy and sad paths

+45
--

=== Promise/Future
[source,java]
----
var someTimeLater = CompletableFuture.supplyAsync(() -> {
    Thread.sleep(new Random().nextLong());
    return Clock.systemUTC().instant();
});

// do other work

someTimeLater.get();
----

* A result that _may_ be available later
* ... or not be ready yet
* ... or may have failed

[.notes]
--
* There are different implementations of `Future`, and your language may call them `Promise` s, but they
all express the idea of a value that may not be available _yet_
* They provide an API to handle errors and timeouts, and usually express a way to use a default value

+30
--

=== Either/Maybe
* May be successful
* ... or maybe not

[source,java]
----
Either<Error, Thing> buildTheThing() {...}


var maybeAThing = buildTheThing();

if (maybeAThing.isRight()) {
    return maybeAThing.get();
} else {
    maybeAThing.getLeft().explainError();
}
----

[.notes]
--
* The `buildTheThing` method returns an instance of the `Either` type
* As with the `Optional` type, there are two possible results, but instead of something or nothing
the type wraps one of two concrete outcomes - *left* or *right*
* A common use is returning errors - perhaps the result of validating some input.  By convention the
successful value is _right_, and the alternative is _left_.
* There are other types like this, such as `Try`, and there are ways to work with them to build expressive
pipelines of functions, but that's another story.

+30
--

== More complex types

[source,haskell]
----
data BillingInfo = CreditCard CardNumber CardHolder Address
                 | CashOnDelivery
                 | Invoice CustomerID
----

* Algebraic Data Type
* Expresses one of a range of choices

[.notes]
--
* This Haskell code expresses the concept that billing
information can be
** A credit card, defined by some properties
** cash on delivery
** an invoice, for a specific customer-ID
* Features in other languages can express similar concepts, although not quite as elegantly - a class hierarchy
for example.

+45
--

== `State.CLOSING_THOUGHTS`
* Languages enable and constrain
* Expressing intent is an investment
* Code is there to be *read*

[.notes]
--
* While I've talked a lot about static types and OO languages it's worth reinforcing that the concepts are
just as valid in dynamically-checked languages, and for procedural and functional styles.
* *But* if you do use a statically typed language, thinking about types and using some of these techniques can
help to make the code you write safer, and easier to work with and understand.
* That expressiveness is a big part of what I enjoy about developing in statically typed languages; as developers
we spend *so* much more time reading code than writing it, using types that express the intent and behaviour leaves
me more time to think and less need to guess and assume.
* The languages and tools we use both enable and constrain, by embracing the constraints of the type system
we can make it more valuable to us in our day to day work, and to the systems we build.

+45
--

== `State.DONE`

* Links
** This presentation
*** https://github.com/tonybaines/types-presentation
** A micro-type implementation in Java
*** https://github.com/tonybaines/java-micro-types

[.notes]
--
* Questions?
--