= Types
2019-04-04
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: src]
:source-highlighter: highlightjs
:icons: font
:revealjs_theme: sky
:revealjs_slideNumber: h.v

== Types of Typing
* Checked/Unchecked/Weak/Strong
* Static/Dynamic


=== Dynamic
[source,ruby]
----
def greet(name)
  return "Hello " + name
end

hello("Tony") # Hello Tony
hello(3)      # TypeError (runtime)
----
* Ruby determines the type of a reference at runtime
* Test coverage is important to stop this happening

=== Static
[source,java]
----
String greet(String name) {
    return "Hello " + name;
}

hello("Tony");

hello(3); // Compliation fails
----
* Java *must* know the type of a reference at compile time
* Test coverage is more about behaviours

=== Except ...



=== `Object`

[source,java]
----
String greet(Object name) {
    return "Hello " + name;
}

hello("Tony");

hello(3);
----

* Successful, but not checked until runtime

=== What about ...?

[source,java]
----
String greet(Object name, Object repeat) {
    return "Hello ".repeat((int)repeat) + name;
}

greet("Tony", 3);
greet(3, "Tony");
----
[.step]
* Both compile
* Runtime exception
* But who'd do that?

=== `Map`

[source,java]
----
String greetMany(Map<String, Integer> people) {
    StringBuilder greetings = new StringBuilder();
    people.forEach( (name, repeat) -> {
        greetings.append("Hello ".repeat(repeat) + name);
    });
    return greetings.toString();
}

Map people = new HashMap() {{
    put("Tony", 3);
    put(3, "Tony");
}};
greetMany(people);
----
[.step]
* Runtime exception
* But who'd do that?

=== `String`

[source,java]
----
String greet(String name, String place) {
    return "Hello " + name + " from " + place;
}

greet("Alice", "London");
greet("Leeds", "Bob");

----
[.step]
* Runtime confusion


== Tiny Types

=== Is this better?
[source,java]
----
String greet(Name person, City city) {
    return "Hello " + person.givenName + " " + city;
}

Name theresa = Name.of("Theresa");
City london = Name.of("London");
greet(theresa, london);

LatLon position = locationOf(london);
----

=== Why they're useful
* Compile-time safety
* Good OO
* IDE auto-completion
* Refactoring

== Enumerations
* A fixed set of options
* Can also implement an `interface`

== Nullable?
* A `String` which can hold a null reference
* A `String` which can only have a value
** Are they the same type?
* Kotlin / C#

== Types-in-a-box
=== Promise/Future
* A result that _may_ be available later
* ... or may be an exception

=== Option(al)
* A result that may not be there

=== Either/Maybe
* May be successful
* ... or maybe not

=== Why are they useful?
* Deferred error handling / synchronisation

[source,java]
----
void sayTheTime(Future<Instant> time) {
    try {
        // Success and a result
        System.out.println(DateTimeFormatter.ISO_DATE.format(time.get()));
    } catch (Exception e) {
        e.printStackTrace(); // Failure
    }
}

CompletableFuture<Instant> someTimeLater(String name) {
    return CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(new Random().nextLong());
            System.out.println(name + " is done");
            return Clock.systemUTC().instant();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
}

CompletableFuture<Instant> foo = someTimeLater("foo");
CompletableFuture<Instant> bar = someTimeLater("bar");
CompletableFuture winner = CompletableFuture.anyOf(foo, bar);
sayTheTime(winner);
----
