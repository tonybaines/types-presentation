= How strong are your types?
2019-07-31
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: src]
:source-highlighter: highlightjs
:icons: font
:revealjs_theme: sky
:revealjs_slideNumber: h.v


== Outline
* An overview of typing
* The art of typing without typing
* Making types work harder

[.notes]
--
* This is a discussion about types as they're used in day-to-day development - there will be code
* I'll do my best to define terms as I go, but ask if I miss something or if I've explained it badly
* Most of the examples will be in Java, once again just ask if the syntax doesn't make sense
* One last thing; although I prefer static typing, this isn't about bashing dynamically-typed languages,
but it may give some insight into why some people like them. I hope I'll also prompt developers in any
language to think about whether they could use types more effectively.
--

== What is a 'Type'
* State / Information
* Will have operations associated with it
** Part of the type - Objects and methods
** Functions which take or return the type

[.notes]
--
* Types represent a way to hold some state in our programs
* To be useful we'll write code that uses instances of these types, or maybe returns them
* In the OO paradigm that's usually methods and state in a class
* Procedural and functional styles might include functions and the types they work with in a common module
--

== Types of Typing
* Checked/Unchecked/Weak/Strong
* Static/Dynamic
* Trade-offs
** Compilation cost
** Feedback time for mistakes
** Clarity/Verbosity

[.notes]
--
* We tend to talk about types in a pretty loose way; languages which have weak or strong type systems
but I couldn't find good definitions for what those terms really mean.
* A clearer distinction is between static type-checking (at compile time) and dynamic type-checking at run time
* There are trade-offs to be made by language designers
** Type checks need extra work at compile time, it takes longer between making a change and being able to run it
** Errors like typo's won't show up until runtime if the checks don't happen during compilation
** Types in code, whether compiled or not, help to explain the logic to another programmer
** Some strongly typed languages clutter source code with duplicated detail (I'm looking at you, Java)
--

=== Dynamic
[source,ruby]
----
def greet(name)
  return "Hello " + name
end

hello("Tony") # Hello Tony
hello(3)      # TypeError (runtime)
----
* Ruby determines the type of a reference at runtime
** The 'shape' of the object is _assumed_
* Test coverage is important to check assumptions

[.notes]
--
* This is an example in Ruby, a language with runtime type-checking
* The `greet` function uses the `+` operator on the "Hello " string, which
expects another string on the right-hand side.
* Nowhere does the code explicitly state what type `name` has, or what type is returned
* We can call `greet` and pass any object we want, but unless it is a string we'll get
an error when we run it
** `(no implicit conversion of Integer into String)`
* When writing production software some extra test effort is needed to make sure everything
lines up
** It's not unusual for Ruby projects to require 100% coverage of all code with automated tests
--

=== Static
[source,java]
----
String greet(String name) {
    return "Hello " + name;
}

hello("Tony");

hello(3); // Compilation fails
----
* Java *must* know the type of a reference at compile time
** The 'shape' of the object is _known_
* Test coverage focuses on behaviours

[.notes]
--
* Here's the equivalent Java code, notice that both the `name` parameter and the return value have an explicit type
* It's impossible to build code where `greet` is called with anything *except* a `String`
* So that's it; Java is type-safe, it's impossible to get a runtime error for an invalid type.
--

=== Except ...



=== `Object`

[source,java]
----
String greet(Object name) {
    return "Hello " + name;
}

hello("Tony");

hello(3);
----

* Successful, but not checked until runtime

[.notes]
--
* Java has the special `Object` class that every class inherits from
* As it happens, the code above both compiles *and* runs successfully because ... TODO
--

=== What about ...?

[source,java]
----
String greet(Object name, Object repeat) {
    return "Hello ".repeat((int)repeat) + name;
}

greet("Tony", 3);
greet(3, "Tony");
----
[.step]
* Both compile
* Runtime exception
* But who'd do that?

=== `Map`

[source,java]
----
String greetMany(Map<String, Integer> people) {
    StringBuilder greetings = new StringBuilder();
    people.forEach( (name, repeat) -> {
        greetings.append("Hello ".repeat(repeat) + name);
    });
    return greetings.toString();
}

Map people = new HashMap() {{
    put("Tony", 3);
    put(3, "Tony");
}};
greetMany(people);
----
[.step]
* Runtime exception
* But who'd do that?

=== `String`

[source,java]
----
String greet(String name, String place) {
    return "Hello " + name + " from " + place;
}

greet("Alice", "London");
greet("Leeds", "Bob");

----
[.step]
* Runtime confusion


== Tiny Types

=== Is this better?
[source,java]
----
String greet(Name person, City city) {
    return "Hello " + person.givenName + " " + city;
}

Name theresa = Name.of("Theresa");
City london = City.of("London");
greet(theresa, london);

LatLon position = locationOf(london);
----

=== Why they're useful
* Compile-time safety
* Good OO
* IDE auto-completion
* Refactoring

== Enumerations
* A fixed set of options
* Can also implement an `interface`

== Nullable?
* A `String` which can hold a null reference
* A `String` which can only have a value
** Are they the same type?
* Kotlin / C#

== Types-in-a-box
* These types express uncertainty
* Can defer resolving the uncertainty
* Something like schr√∂dinger's cat

=== Promise/Future
* A result that _may_ be available later
* ... or may be an exception

=== Optional
* A result that may not be there

[source,java]
----
Optional<TimeSlot> nextFreeMeetingSlot(Criteria criteria) {...}
Optional<MeetingRequest> bookMeeting(Instant startTime,
                                        Duration duration) {...}

Meeting meeting =
    nextFreeMeetingSlot(criteria)
        .filter(timeSlot ->
            myDiary.isFree(timeSlot))
        .map(timeSlot ->
            timeSlot.startTime)
        .flatMap(startTime ->
            bookMeeting(startTime, minutes(15)))
        .orElseThrow(
            new MeetingException("No meeting slot available")
        );
----

=== Optional
* Express the 'happy path'
* Handle errors from any step
** Each of the first three steps might result in a 'not-present'

=== Either/Maybe
* May be successful
* ... or maybe not

=== Why are they useful?
* Deferred error handling / synchronisation

[source,java]
----
void sayTheTime(Future<Instant> time) {
    try {
        // Success and a result
        println(DateTimeFormatter.ISO_DATE.format(time.get()));
    } catch (Exception e) {
        e.printStackTrace(); // Failure
    }
}

CompletableFuture<Instant> someTimeLater(String name) {
    return CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(new Random().nextLong());
            System.out.println(name + " is done");
            return Clock.systemUTC().instant();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
}

CompletableFuture<Instant> foo = someTimeLater("foo");
CompletableFuture<Instant> bar = someTimeLater("bar");
CompletableFuture winner = CompletableFuture.anyOf(foo, bar);
sayTheTime(winner);
----

== More complex types

[source,haskell]
----
data BillingInfo = CreditCard CardNumber CardHolder Address
                 | CashOnDelivery
                 | Invoice CustomerID
----

* This Haskell code expresses the concept that billing
information can be
** A credit card, defined by some properties
** cash on delivery
** an invoice, for a specific customer-ID

== Types express meaning
* The programming language enables and constrains
* How we use the language makes a difference