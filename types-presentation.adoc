= Types
2019-04-04
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: src]
:source-highlighter: highlightjs
:icons: font
:revealjs_theme: sky
:revealjs_slideNumber: h.v

== Types of Typing
* Checked/Unchecked/Weak/Strong
* Static/Dynamic


=== Dynamic
[source,ruby]
----
def greet(name)
  return "Hello " + name
end

hello("Tony") # Hello Tony
hello(3)      # TypeError (runtime)
----
* Ruby determines the type of a reference at runtime
** The 'shape' of the object is _assumed_
* Test coverage is important to check assumptions

=== Static
[source,java]
----
String greet(String name) {
    return "Hello " + name;
}

hello("Tony");

hello(3); // Compliation fails
----
* Java *must* know the type of a reference at compile time
** The 'shape' of the object is _known_
* Test coverage focuses on behaviours

=== Except ...



=== `Object`

[source,java]
----
String greet(Object name) {
    return "Hello " + name;
}

hello("Tony");

hello(3);
----

* Successful, but not checked until runtime

=== What about ...?

[source,java]
----
String greet(Object name, Object repeat) {
    return "Hello ".repeat((int)repeat) + name;
}

greet("Tony", 3);
greet(3, "Tony");
----
[.step]
* Both compile
* Runtime exception
* But who'd do that?

=== `Map`

[source,java]
----
String greetMany(Map<String, Integer> people) {
    StringBuilder greetings = new StringBuilder();
    people.forEach( (name, repeat) -> {
        greetings.append("Hello ".repeat(repeat) + name);
    });
    return greetings.toString();
}

Map people = new HashMap() {{
    put("Tony", 3);
    put(3, "Tony");
}};
greetMany(people);
----
[.step]
* Runtime exception
* But who'd do that?

=== `String`

[source,java]
----
String greet(String name, String place) {
    return "Hello " + name + " from " + place;
}

greet("Alice", "London");
greet("Leeds", "Bob");

----
[.step]
* Runtime confusion


== Tiny Types

=== Is this better?
[source,java]
----
String greet(Name person, City city) {
    return "Hello " + person.givenName + " " + city;
}

Name theresa = Name.of("Theresa");
City london = City.of("London");
greet(theresa, london);

LatLon position = locationOf(london);
----

=== Why they're useful
* Compile-time safety
* Good OO
* IDE auto-completion
* Refactoring

== Enumerations
* A fixed set of options
* Can also implement an `interface`

== Nullable?
* A `String` which can hold a null reference
* A `String` which can only have a value
** Are they the same type?
* Kotlin / C#

== Types-in-a-box
* These types express uncertainty
* Can defer resolving the uncertainty
* Something like schr√∂dinger's cat

=== Promise/Future
* A result that _may_ be available later
* ... or may be an exception

=== Optional
* A result that may not be there

[source,java]
----
Optional<TimeSlot> nextFreeMeetingSlot(Criteria criteria) {...}
Optional<MeetingRequest> bookMeeting(Instant startTime,
                                        Duration duration) {...}

Meeting meeting =
    nextFreeMeetingSlot(criteria)
        .filter(timeSlot ->
            myDiary.isFree(timeSlot))
        .map(timeSlot ->
            timeSlot.startTime)
        .flatMap(startTime ->
            bookMeeting(startTime, minutes(15)))
        .orElseThrow(
            new MeetingException("No meeting slot available")
        );
----

=== Optional
* Express the 'happy path'
* Handle errors from any step
** Each of the first three steps might result in a 'not-present'

=== Either/Maybe
* May be successful
* ... or maybe not

=== Why are they useful?
* Deferred error handling / synchronisation

[source,java]
----
void sayTheTime(Future<Instant> time) {
    try {
        // Success and a result
        println(DateTimeFormatter.ISO_DATE.format(time.get()));
    } catch (Exception e) {
        e.printStackTrace(); // Failure
    }
}

CompletableFuture<Instant> someTimeLater(String name) {
    return CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(new Random().nextLong());
            System.out.println(name + " is done");
            return Clock.systemUTC().instant();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
}

CompletableFuture<Instant> foo = someTimeLater("foo");
CompletableFuture<Instant> bar = someTimeLater("bar");
CompletableFuture winner = CompletableFuture.anyOf(foo, bar);
sayTheTime(winner);
----

== More complex types

[source,haskell]
----
data BillingInfo = CreditCard CardNumber CardHolder Address
                 | CashOnDelivery
                 | Invoice CustomerID
----

* This Haskell code expresses the concept that billing
information can be
** A credit card, defined by some properties
** cash on delivery
** an invoice, for a specific customer-ID

== Types express meaning
* The programming language enables and constrains
* How we use the language makes a difference