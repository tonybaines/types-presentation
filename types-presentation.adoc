= How strong are your types?
2019-07-31
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: src]
:source-highlighter: highlightjs
:icons: font
:revealjs_theme: sky
:revealjs_slideNumber: h.v


== Outline
* An overview of typing
* The art of typing without typing
* Making types work harder

[.notes]
--
* This is a discussion about types as they're used in day-to-day development - there will be code
* I'll do my best to define terms as I go, but ask if I miss something or if I've explained it badly
* Most of the examples will be in Java, once again just ask if the syntax doesn't make sense
* One last thing; although I prefer static typing, this isn't about bashing dynamically-typed languages,
but it may give some insight into why some people like them. I hope I'll also prompt developers in any
language to think about whether they could use types more effectively.
--

== What is a 'Type'
* State / Information
* Will have operations associated with it
** Part of the type - Objects and methods
** Functions which take or return the type

[.notes]
--
* Types represent a way to hold some state in our programs
* To be useful we'll write code that uses instances of these types, or maybe returns them
* In the OO paradigm that's usually methods and state in a class
* Procedural and functional styles might include functions and the types they work with in a common module
--

== Types of Typing
* Checked/Unchecked/Weak/Strong
* Static/Dynamic
* Trade-offs
** Compilation cost
** Feedback time for mistakes
** Clarity/Verbosity

[.notes]
--
* We tend to talk about types in a pretty loose way; languages which have weak or strong type systems
but I couldn't find good definitions for what those terms really mean.
* A clearer distinction is between static type-checking (at compile time) and dynamic type-checking at run time
* There are trade-offs to be made by language designers
** Type checks need extra work at compile time, it takes longer between making a change and being able to run it
** Errors like typo's won't show up until runtime if the checks don't happen during compilation
** Types in code, whether compiled or not, help to explain the logic to another programmer
** Some strongly typed languages clutter source code with duplicated detail (I'm looking at you, Java)
--

=== Dynamic
[source,ruby]
----
def greet(name)
  return "Hello " + name
end

hello("Tony") # Hello Tony
hello(3)      # TypeError (runtime)
----
* Ruby determines the type of a reference at runtime
** The 'shape' of the object is _assumed_
* Test coverage is important to check assumptions

[.notes]
--
* This is an example in Ruby, a language with runtime type-checking
* The `greet` function uses the `+` *method* on the "Hello " string, which
expects another string on the right-hand side.
* Nowhere does the code explicitly state what type `name` has, or what type is returned
* We can call `greet` and pass any object we want, but unless it is a string we'll get
an error when we run it
** `(no implicit conversion of Integer into String)`
* When writing production software some extra test effort is needed to make sure everything
lines up
** It's not unusual for Ruby projects to require 100% coverage of all code with automated tests
--

=== Static
[source,java]
----
String greet(String name) {
    return "Hello " + name;
}

hello("Tony");

hello(3); // Compilation fails
----
* Java *must* know the type of a reference at compile time
** The 'shape' of the object is _known_
* Test coverage focuses on behaviours

[.notes]
--
* Here's the equivalent Java code, notice that both the `name` parameter and the return value have an explicit type
* It's impossible to build code where `greet` is called with anything *except* a `String`
* So that's it; Java is type-safe, it's impossible to get a runtime error for an invalid type.
--

=== Except ...



=== `Object`

[source,java]
----
String greet(Object name) {
    return "Hello " + name;
}

hello("Tony");

hello(3);
----

* Successful, but not checked until runtime

[.notes]
--
* Java has the special `Object` class that every class inherits from
* As it happens, the code above both compiles *and* runs successfully because in Java the '+' the right hand side
has `toString()` called on it - changing the type to `String`
--

=== What about ...?

[source,java]
----
String greet(Object name, Object repeat) {
    return "Hello ".repeat((int)repeat) + name;
}

greet("Tony", 3);
greet(3, "Tony"); // runtime exception
----
[.step]
* Compiles
* Runtime exception
* But who'd do that?

[.notes]
--
* Here's a contrived example where the Java code compiles, but fails at runtime
* There's a lot of ceremony where the `repeat` object is *cast* to type `int`, because that's
the type that the `repeat` method needs
* The first call succeeds, the second causes an exception at runtime
* This is one example of dynamic typing in Java, there are others, but I won't go into them now.
* But why would anyone choose to do that?
--

=== `Map`

[source,java]
----
String greetMany(Map<String, Integer> people) {
    var greetings = new StringBuilder();
    people.forEach( (name, repeat) -> {
        greetings.append("Hello ".repeat(repeat) + name);
    });
    return greetings.toString();
}

Map people = new HashMap() {{
    put("Tony", 3);
    put(3, "Tony");
}};
greetMany(people); // runtime exception
----
[.step]
* Compiles
* Runtime exception
* But who'd do that?

[.notes]
--
* This is what I think of in my head as _"the art of typing without typing"_
* The code has types defined, but they only enforced in limited ways
* The method `greet` has a well defined contract, and it looks like there should be a compilation failure
* Because of the history of the Java language, *Generics* (that's the information in the angle brackets) aren't
enforced when dealing with so-called *raw* collections.
* Notice the `var` keyword - that became valid syntax in Java 10 and is an example of _Type Inference_, where the
type of `greetings` is inferred from the expression on the right hand side.
* It's still early days for Java but it does help to reduce the clutter of Java code.
* This sort of mistake is much easier to make, but is easily detected by static analysis tools.
--

=== `String`

[source,java]
----
String greet(String name, String place) {
    return "Hello " + name + " from " + place;
}

greet("Alice", "London");
greet("Leeds", "Bob");

----
[.step]
* Runtime confusion

[.notes]
--
* This one example of where relying on the types native to your programming language may not be enough.
* The intent of the method is straightforward, it compiles and runs *and there's no exception*
* This is a more subtle failure which may not be detected by automated tests.
* Although this is a simple example I'm sure we all have examples in our code bases where there are
lists of `String` and numeric types passed into methods which use some of them to call other methods, perhaps
in a different order.
* This passing around of data is a common place for subtle bugs to accumulate, and makes reasoning about such code
harder than it needs to be.
--

== Tiny Types

=== Is this better?
[source,java]
----
String greet(Name person, City city) {
    return "Hello " + person.givenName + " from " + city;
}

Name theresa = Name.of("Theresa");
City london = City.of("London");
greet(theresa, london);
//greet(london, theresa); // compile fails

----

[.notes]
--
* This is the same method, but we've moved away from the _"Stringly Typed"_ definition
* It's a compilation failure to put these values the wrong way around when calling `greet`
* The typed-values, once defined, can be used safely in other calls
* Conversion from `String` etc is only necessary once at system boundaries, when data is received.
--

=== Why they're useful
[source,java]
----
LatLon position = london.location();
----
* Compile-time safety
* Good OO
* IDE auto-completion
* Refactoring

[.notes]
--
* As well as adding extra safety to check for easy mistakes during compilation
* In OO style, once there is a class that represents *Name* or *Location* it will naturally
attract associated methods - such as the coordinates of a geographical location.
* An IDE such as IntelliJ will automatically pick the correct values from local scope to pass
into a function call.
* Refactoring becomes easier - there's once place to change e.g. how identifiers are stored
--

== Enumerations
[source,java]
----
enum RAG {Red, Amber, Green}
----
* A fixed set of options
* Can also implement an `interface`

[.notes]
--
* There's a lot more to say about tiny types, including how they're implemented and the
trade-offs that they require, but I want to just cover a few more ways of where types can help.
* If a type represents a fixed set of values, an enumeration can be an easy choice
* In Java, enums can implement interfaces and have methods.
--

== Nullable?
* A `String` which can hold a null reference
* A `String` which can only have a value
** Are they the same type?

[source,java]
----
// Kotlin
val nullable: String? = null   // OK
val notNullable: String = null // compilation error
----

[.notes]
--
* `null` or `nil` has fallen out of favour, the inventor of the null reference , Tony Hoare, refers
to it as his _"billion-dollar mistake"_
* Kotlin, which prioritises interoperability with Java, has a style which strongly discourages `null`,
but has mechanisms in the language to express and constrain valid values
--

== Types-in-a-box
* These types express uncertainty
* Can defer resolving the uncertainty
* Something like schr√∂dinger's cat

[.notes]
--
* There are another category of types that are becoming more popular
--

=== Optional
* A result that may not be there

[source,java]
----
Optional<TimeSlot> nextFreeMeetingSlot(Criteria criteria) {...}
Optional<MeetingRequest> bookMeeting(Instant startTime,
                                        Duration duration) {...}

Meeting meeting =
    nextFreeMeetingSlot(criteria)
        .filter(timeSlot ->
            myDiary.isFree(timeSlot))
        .map(timeSlot ->
            timeSlot.startTime)
        .flatMap(startTime ->
            bookMeeting(startTime, minutes(15)))
        .orElseThrow(
            new MeetingException("No meeting slot available")
        );
----

=== Optional
* Express the 'happy path'
* Handle errors from any step
** Each of the first three steps might result in a 'not-present'

=== Promise/Future
* A result that _may_ be available later
* ... or may be an exception

=== Either/Maybe
* May be successful
* ... or maybe not

=== Why are they useful?
* Deferred error handling / synchronisation

[source,java]
----
void sayTheTime(Future<Instant> time) {
    try {
        // Success and a result
        println(DateTimeFormatter.ISO_DATE.format(time.get()));
    } catch (Exception e) {
        e.printStackTrace(); // Failure
    }
}

CompletableFuture<Instant> someTimeLater(String name) {
    return CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(new Random().nextLong());
            System.out.println(name + " is done");
            return Clock.systemUTC().instant();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
}

CompletableFuture<Instant> foo = someTimeLater("foo");
CompletableFuture<Instant> bar = someTimeLater("bar");
CompletableFuture winner = CompletableFuture.anyOf(foo, bar);
sayTheTime(winner);
----

== More complex types

[source,haskell]
----
data BillingInfo = CreditCard CardNumber CardHolder Address
                 | CashOnDelivery
                 | Invoice CustomerID
----

* This Haskell code expresses the concept that billing
information can be
** A credit card, defined by some properties
** cash on delivery
** an invoice, for a specific customer-ID

== Types express meaning
* The programming language enables and constrains
* How we use the language makes a difference